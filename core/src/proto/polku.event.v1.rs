// This file is @generated by prost-build.
/// NetworkEventData contains network-level event information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEventData {
    /// TCP, UDP, DNS, HTTP, gRPC
    #[prost(string, tag = "1")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub src_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub dst_ip: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub src_port: u32,
    #[prost(uint32, tag = "5")]
    pub dst_port: u32,
    /// inbound, outbound
    #[prost(string, tag = "6")]
    pub direction: ::prost::alloc::string::String,
    /// DNS
    #[prost(string, tag = "7")]
    pub dns_query: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub dns_response: ::prost::alloc::string::String,
    /// HTTP
    #[prost(string, tag = "9")]
    pub http_method: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub http_path: ::prost::alloc::string::String,
    #[prost(int32, tag = "11")]
    pub http_status_code: i32,
    /// Metrics
    #[prost(double, tag = "12")]
    pub latency_ms: f64,
    #[prost(uint64, tag = "13")]
    pub bytes_sent: u64,
    #[prost(uint64, tag = "14")]
    pub bytes_received: u64,
    /// TCP performance
    #[prost(double, tag = "15")]
    pub rtt_baseline_ms: f64,
    #[prost(double, tag = "16")]
    pub rtt_current_ms: f64,
    #[prost(double, tag = "17")]
    pub rtt_degradation_pct: f64,
    #[prost(uint32, tag = "18")]
    pub retransmit_count: u32,
    #[prost(string, tag = "19")]
    pub tcp_state: ::prost::alloc::string::String,
    /// K8s context
    #[prost(string, tag = "20")]
    pub process_name: ::prost::alloc::string::String,
    #[prost(string, tag = "21")]
    pub container_id: ::prost::alloc::string::String,
    #[prost(string, tag = "22")]
    pub pod_name: ::prost::alloc::string::String,
}
/// KernelEventData contains kernel-level event information (eBPF events)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelEventData {
    /// oom_kill, signal, syscall
    #[prost(string, tag = "1")]
    pub event_type: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub pid: u32,
    #[prost(string, tag = "3")]
    pub command: ::prost::alloc::string::String,
    /// OOM
    #[prost(uint32, tag = "4")]
    pub oom_victim_pid: u32,
    #[prost(string, tag = "5")]
    pub oom_victim_comm: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub memory_requested: u64,
    /// Signals
    #[prost(uint32, tag = "7")]
    pub signal: u32,
    #[prost(uint32, tag = "8")]
    pub signal_code: u32,
    /// Syscalls
    #[prost(uint32, tag = "9")]
    pub syscall_id: u32,
    #[prost(string, tag = "10")]
    pub syscall_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "11")]
    pub syscall_retval: i64,
}
/// ContainerEventData contains container lifecycle and resource events
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerEventData {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub container_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    /// running, stopped, crashed
    #[prost(string, tag = "4")]
    pub state: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub exit_code: i32,
    #[prost(int32, tag = "6")]
    pub restart_count: i32,
    #[prost(message, optional, tag = "7")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Resources
    ///
    /// cores
    #[prost(double, tag = "8")]
    pub cpu_usage: f64,
    /// bytes
    #[prost(uint64, tag = "9")]
    pub memory_usage: u64,
    #[prost(uint64, tag = "10")]
    pub memory_limit: u64,
    #[prost(uint64, tag = "11")]
    pub disk_usage: u64,
    /// OOM details
    #[prost(int32, tag = "12")]
    pub signal: i32,
    #[prost(string, tag = "13")]
    pub cgroup_path: ::prost::alloc::string::String,
}
/// K8sEventData contains Kubernetes API events
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct K8sEventData {
    /// Deployment, Pod, Service
    #[prost(string, tag = "1")]
    pub resource_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub resource_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub namespace: ::prost::alloc::string::String,
    /// Scheduled, Pulling, Created, Started
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub message: ::prost::alloc::string::String,
    /// Deployment specifics
    #[prost(int32, tag = "6")]
    pub replicas: i32,
    #[prost(int32, tag = "7")]
    pub ready_replicas: i32,
    #[prost(int32, tag = "8")]
    pub updated_replicas: i32,
    /// progressing, complete, failed
    #[prost(string, tag = "9")]
    pub rollout_status: ::prost::alloc::string::String,
}
/// ProcessEventData contains process lifecycle events
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessEventData {
    #[prost(uint32, tag = "1")]
    pub pid: u32,
    #[prost(uint32, tag = "2")]
    pub ppid: u32,
    #[prost(string, tag = "3")]
    pub command: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub args: ::prost::alloc::string::String,
    #[prost(uint32, tag = "5")]
    pub uid: u32,
    #[prost(uint32, tag = "6")]
    pub gid: u32,
    #[prost(string, tag = "7")]
    pub user: ::prost::alloc::string::String,
    #[prost(int32, tag = "8")]
    pub exit_code: i32,
    #[prost(message, optional, tag = "9")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// ResourceEventData contains node/resource utilization events
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceEventData {
    /// cpu, memory, disk, network
    #[prost(string, tag = "1")]
    pub resource_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub node_name: ::prost::alloc::string::String,
    /// CPU
    #[prost(double, tag = "3")]
    pub cpu_usage_pct: f64,
    #[prost(double, tag = "4")]
    pub cpu_throttle_pct: f64,
    /// Memory
    #[prost(uint64, tag = "5")]
    pub memory_used: u64,
    #[prost(uint64, tag = "6")]
    pub memory_available: u64,
    #[prost(double, tag = "7")]
    pub memory_pressure: f64,
    /// Disk
    #[prost(uint64, tag = "8")]
    pub disk_used: u64,
    #[prost(uint64, tag = "9")]
    pub disk_available: u64,
    #[prost(double, tag = "10")]
    pub disk_io_utilization: f64,
}
/// Event is POLKU's internal event envelope.
///
/// This is what Ingestors produce and Emitters consume.
/// Events flow through the POLKU pipeline:
///    Ingestors → Middleware → Buffer → Emitters
///
/// Events can carry typed data (preferred) or opaque payload bytes (legacy).
/// When typed data is present, ahti-emitter maps it directly to AhtiEvent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// Unique event ID (ULID recommended)
    ///
    /// Should be globally unique. If not provided, POLKU will generate one.
    /// ULIDs are preferred as they're sortable by time.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Unix timestamp in nanoseconds
    ///
    /// When the event occurred, not when it was received.
    /// If not provided, POLKU will set it to the current time.
    #[prost(int64, tag = "2")]
    pub timestamp_unix_ns: i64,
    /// Source that produced this event
    ///
    /// Identifies the origin of the event (e.g., "tapio", "portti", "elava").
    /// Used for routing and filtering.
    #[prost(string, tag = "3")]
    pub source: ::prost::alloc::string::String,
    /// User-defined event type
    ///
    /// A hierarchical type identifier (e.g., "network.connection", "k8s.pod.created").
    /// Used for routing, filtering, and transformation.
    #[prost(string, tag = "4")]
    pub event_type: ::prost::alloc::string::String,
    /// Arbitrary key-value metadata
    ///
    /// Additional context about the event that doesn't belong in the payload.
    /// Common keys: "cluster", "namespace", "trace_id", "span_id"
    #[prost(map = "string, string", tag = "5")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Legacy: opaque payload bytes
    ///
    /// DEPRECATED: Prefer using the typed `data` oneof below.
    /// Can be any format: JSON, protobuf, msgpack, etc.
    /// Emitters must parse based on event_type.
    #[prost(bytes = "vec", tag = "6")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// Optional routing hints for Emitters
    ///
    /// If non-empty, only emitters with matching names will receive this event.
    /// If empty, all emitters receive the event (fan-out).
    #[prost(string, repeated, tag = "7")]
    pub route_to: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Classification
    #[prost(enumeration = "Severity", tag = "10")]
    pub severity: i32,
    #[prost(enumeration = "Outcome", tag = "11")]
    pub outcome: i32,
    /// Typed event data - only one populated per event
    #[prost(oneof = "event::Data", tags = "20, 21, 22, 23, 24, 25")]
    pub data: ::core::option::Option<event::Data>,
}
/// Nested message and enum types in `Event`.
pub mod event {
    /// Typed event data - only one populated per event
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "20")]
        Network(super::NetworkEventData),
        #[prost(message, tag = "21")]
        Kernel(super::KernelEventData),
        #[prost(message, tag = "22")]
        Container(super::ContainerEventData),
        #[prost(message, tag = "23")]
        K8s(super::K8sEventData),
        #[prost(message, tag = "24")]
        Process(super::ProcessEventData),
        #[prost(message, tag = "25")]
        Resource(super::ResourceEventData),
    }
}
/// Severity indicates the importance/urgency of an event
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
    Unspecified = 0,
    Debug = 1,
    Info = 2,
    Warning = 3,
    Error = 4,
    Critical = 5,
}
impl Severity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SEVERITY_UNSPECIFIED",
            Self::Debug => "SEVERITY_DEBUG",
            Self::Info => "SEVERITY_INFO",
            Self::Warning => "SEVERITY_WARNING",
            Self::Error => "SEVERITY_ERROR",
            Self::Critical => "SEVERITY_CRITICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
            "SEVERITY_DEBUG" => Some(Self::Debug),
            "SEVERITY_INFO" => Some(Self::Info),
            "SEVERITY_WARNING" => Some(Self::Warning),
            "SEVERITY_ERROR" => Some(Self::Error),
            "SEVERITY_CRITICAL" => Some(Self::Critical),
            _ => None,
        }
    }
}
/// Outcome indicates the result of an operation
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Outcome {
    Unspecified = 0,
    Success = 1,
    Failure = 2,
    Timeout = 3,
    Unknown = 4,
}
impl Outcome {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OUTCOME_UNSPECIFIED",
            Self::Success => "OUTCOME_SUCCESS",
            Self::Failure => "OUTCOME_FAILURE",
            Self::Timeout => "OUTCOME_TIMEOUT",
            Self::Unknown => "OUTCOME_UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OUTCOME_UNSPECIFIED" => Some(Self::Unspecified),
            "OUTCOME_SUCCESS" => Some(Self::Success),
            "OUTCOME_FAILURE" => Some(Self::Failure),
            "OUTCOME_TIMEOUT" => Some(Self::Timeout),
            "OUTCOME_UNKNOWN" => Some(Self::Unknown),
            _ => None,
        }
    }
}
